use std::fs::File;
use std::io::{self, Write};
use std::path::{Path, PathBuf};

use clap::Parser;
use vibrato_rkyv::errors::VibratoError;
use vibrato_rkyv::trainer::Model;

pub type FileDictionaryWriters = DictionaryWriters<File, File, File, File, File, File, File>;

#[derive(Parser, Debug)]
#[clap(name = "dictgen", about = "Dictionary generator")]
pub struct Args {
    /// Model file generated by the train command (in zstd).
    #[clap(short = 'i', long)]
    model_in: PathBuf,

    /// A file to which the system lexicon is output (lex.csv).
    #[clap(short = 'l', long)]
    lexicon_out: PathBuf,

    /// A file to which the unknown word definition is output (unk.def).
    #[clap(short = 'u', long)]
    unk_out: PathBuf,

    /// A file to which the matrix is output (matrix.def).
    #[clap(short = 'm', long)]
    matrix_out: PathBuf,

    /// User-defined lexicon file. For which you want to give weights automatically,
    /// set 0 for the connection ID and the weight of such entries.
    #[clap(long)]
    user_lexicon_in: Option<PathBuf>,

    /// A file to which the user-defined lexicon is output.
    #[clap(long)]
    user_lexicon_out: Option<PathBuf>,

    /// Outputs a list of features associated with each connection ID and a list of bi-gram
    /// costs.
    ///
    /// The file names are suffixed with `.left`, `.right`, and `.cost`.
    #[clap(long)]
    conn_id_info_out: Option<PathBuf>,
}

#[derive(Debug, thiserror::Error)]
pub enum DictgenError {
    #[error("I/O error: {0}")]
    Io(#[from] io::Error),

    #[error("Failed to process the model: {0}")]
    Model(#[from] VibratoError),
}

#[derive(Debug, Clone)]
pub struct ConnIdInfoWriters<LW: Write, RW: Write, CW: Write> {
    pub left_wtr: LW,
    pub right_wtr: RW,
    pub cost_wtr: CW,
}

#[derive(Debug, Clone)]
pub struct DictionaryWriters<L, C, U, S, LW, RW, CW>
where
    L: Write, C: Write, U: Write, S: Write,
    LW: Write, RW: Write, CW: Write,
{
    pub lexicon_wtr: L,
    pub matrix_wtr: C,
    pub unk_wtr: U,
    pub user_lexicon_wtr: Option<S>,
    pub conn_id_info_wtrs: Option<ConnIdInfoWriters<LW, RW, CW>>,
}


/// Runs the dictgen subcommand. It parses arguments, loads a model, and calls the core logic.
pub fn run(args: Args) -> Result<(), DictgenError> {
    let model_rdr = zstd::Decoder::new(File::open(args.model_in)?)?;
    let mut model = Model::read_model(model_rdr)?;

    let mut sources = create_dictionary_writers_from_paths(
        &args.lexicon_out,
        &args.matrix_out,
        &args.unk_out,
        args.user_lexicon_out.as_deref(),
        args.conn_id_info_out.as_deref(),
    )?;

    generate_dictionary_files(&mut model, &mut sources)?;

    Ok(())
}

pub fn create_dictionary_writers_from_paths(
    lexicon_out_path: &Path,
    matrix_out_path: &Path,
    unk_out_path: &Path,
    user_lexicon_out_path: Option<&Path>,
    conn_id_info_out_path: Option<&Path>,
) -> Result<
    FileDictionaryWriters,
    io::Error,
> {
    let lexicon_wtr = File::create(lexicon_out_path)?;
    let matrix_wtr = File::create(matrix_out_path)?;
    let unk_wtr = File::create(unk_out_path)?;

    let user_lexicon_wtr = user_lexicon_out_path.map(File::create).transpose()?;

    let conn_id_info_wtrs = conn_id_info_out_path
        .map(|path| -> io::Result<_> {
            let base_name = path.as_os_str().to_os_string();
            let mut left_path = base_name.clone();
            left_path.push(".left");
            let mut right_path = base_name.clone();
            right_path.push(".right");
            let mut cost_path = base_name;
            cost_path.push(".cost");
            Ok(ConnIdInfoWriters {
                left_wtr: File::create(left_path)?,
                right_wtr: File::create(right_path)?,
                cost_wtr: File::create(cost_path)?,
            })
        })
        .transpose()?;

    Ok(DictionaryWriters {
        lexicon_wtr,
        matrix_wtr,
        unk_wtr,
        user_lexicon_wtr,
        conn_id_info_wtrs,
    })
}

pub fn generate_dictionary_files<L, C, U, S, LW, RW, CW>(
    model: &mut Model,
    writers: &mut DictionaryWriters<L, C, U, S, LW, RW, CW>,
) -> Result<(), VibratoError>
where
    L: Write, C: Write, U: Write, S: Write,
    LW: Write, RW: Write, CW: Write,
{
    if let Some(user_wtr) = writers.user_lexicon_wtr.as_mut() {
        model.write_dictionary(
            &mut writers.lexicon_wtr,
            &mut writers.matrix_wtr,
            &mut writers.unk_wtr,
            user_wtr,
        )?;
    } else {
        model.write_dictionary(
            &mut writers.lexicon_wtr,
            &mut writers.matrix_wtr,
            &mut writers.unk_wtr,
            io::sink(),
        )?;
    }

    if let Some(bigram_info) = writers.conn_id_info_wtrs.as_mut() {
        model.write_bigram_details(
            &mut bigram_info.left_wtr,
            &mut bigram_info.right_wtr,
            &mut bigram_info.cost_wtr,
        )?;
    }

    Ok(())
}
